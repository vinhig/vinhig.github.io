<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>A dumb Vulkan Memory Allocator in plain C | Portfolio Vincent Higginson</title>
<meta name=keywords content>
<meta name=description content="By reading the github repository of the famous library Vulkan Memory Allocator written by the AMD team, you will see a kinda huge list of games and apps which are actually using it. From &ldquo;Detroit: Become Human&rdquo; to &ldquo;Skia&rdquo;, they are many who trust it. And they&rsquo;re right in a way. It does the job and it does it right. However, when you&rsquo;re learning a subject, you may want to investigate it deeply.">
<meta name=author content>
<link rel=canonical href=http://vinhig.github.io/posts/vulkan-memory-allocator/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.b9ff4cc257e914dab489bd18086151800e18f91456a5174bf28489210227a659.css integrity="sha256-uf9MwlfpFNq0ib0YCGFRgA4Y+RRWpRdL8oSJIQInplk=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://vinhig.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://vinhig.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://vinhig.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://vinhig.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://vinhig.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.0">
<meta property="og:title" content="A dumb Vulkan Memory Allocator in plain C">
<meta property="og:description" content="By reading the github repository of the famous library Vulkan Memory Allocator written by the AMD team, you will see a kinda huge list of games and apps which are actually using it. From &ldquo;Detroit: Become Human&rdquo; to &ldquo;Skia&rdquo;, they are many who trust it. And they&rsquo;re right in a way. It does the job and it does it right. However, when you&rsquo;re learning a subject, you may want to investigate it deeply.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://vinhig.github.io/posts/vulkan-memory-allocator/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-08-31T12:50:50+02:00">
<meta property="article:modified_time" content="2021-08-31T12:50:50+02:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="A dumb Vulkan Memory Allocator in plain C">
<meta name=twitter:description content="By reading the github repository of the famous library Vulkan Memory Allocator written by the AMD team, you will see a kinda huge list of games and apps which are actually using it. From &ldquo;Detroit: Become Human&rdquo; to &ldquo;Skia&rdquo;, they are many who trust it. And they&rsquo;re right in a way. It does the job and it does it right. However, when you&rsquo;re learning a subject, you may want to investigate it deeply.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://vinhig.github.io/posts/"},{"@type":"ListItem","position":2,"name":"A dumb Vulkan Memory Allocator in plain C","item":"http://vinhig.github.io/posts/vulkan-memory-allocator/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A dumb Vulkan Memory Allocator in plain C","name":"A dumb Vulkan Memory Allocator in plain C","description":"By reading the github repository of the famous library Vulkan Memory Allocator written by the AMD team, you will see a kinda huge list of games and apps which are actually using it. From \u0026ldquo;Detroit: Become Human\u0026rdquo; to \u0026ldquo;Skia\u0026rdquo;, they are many who trust it. And they\u0026rsquo;re right in a way. It does the job and it does it right. However, when you\u0026rsquo;re learning a subject, you may want to investigate it deeply.","keywords":[],"articleBody":"By reading the github repository of the famous library Vulkan Memory Allocator written by the AMD team, you will see a kinda huge list of games and apps which are actually using it. From “Detroit: Become Human” to “Skia”, they are many who trust it. And they’re right in a way. It does the job and it does it right. However, when you’re learning a subject, you may want to investigate it deeply. You do not want to rely on whatever library is giving you some level of comfort (if it wasn’t the case, I would have stayed with OpenGL).\nSo in this post (the first one of my newly created portfolio), I will explain how did I write my dumb memory allocator and why it’s a dumb allocator. I do not ask you to blindly trust me, but I’ve gained some level of confidence as I heavily use it throughout my projects.\nBasics concepts of memory allocation First of all, what’s a memory allocator? Every resource you use in your program is actually a structured representation of bytes present in your physical memory. This piece of memory is characterized by a size and an address (how many bytes would you eat? and where should I find those bytes?). When you’re writing basic CPU code, you’re allocating with malloc (or a similar utility) which returns the actual address of the newly created piece of memory. Working with OpenGL, you’re creating a resource with some specific size and everything is done magically by your driver. Don’t you dare ask where did it put your data, you should not work directly with its address anyway.\nCreating a vulkan resource (buffers and images, for example), doesn’t mean allocating the required space. It’s a separated action you have to execute to make the resource usable (creating an image view, binding the buffer as a vertex buffer, etc). That’s where your allocator comes in. As you created your image with precise dimensions, your buffer with a precise size, it’s easy to guess how your reserved piece of memory should be…\nGuessing the required size There is no guess! All you need is your physical device with which you can invoke:\nVkMemoryRequirements memory_requirements; vkGetImageMemoryRequirements(device, image, memory_requirements); // or vkGetBufferMemoryRequirements(device, image, memory_requirements); Easy easy! memory_requirements now contains everything you need to allocate: a size, a memory type and an alignement.\nAllocating for your resource A computer able to run vulkan code has different types of memory. I won’t detail them exhaustively, but it’s intuitive to think that depending on the usage of your resource, its place will be different. A mappable buffer and a color attachment texture aren’t both requiring the same memory type, for example. In dumb_alloc code, I call them memory region.\nI WANT TO ALLOCATE NOW, WHERE IS THE vkMalloc DUDE??? If you want to rush it, let’s just acquire a VkDeviceMemory every time you need to bind memory to your vulkan object.\nVkMemoryAllocateInfo allocate_info = { .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, .memoryTypeIndex = your_memory_type, .allocationSize = your_size, }; vkAllocateMemory(device, \u0026allocate_info, NULL, \u0026device_memory) Easy, fast, end of my post. You can leave now. The others who stayed, shame on this guy who wanted to speed run its allocation. It’s a horrible practice. The number of memory allocations you can make is, in fact, very variable and limited. It can go from 4.096 to 4.294.970.000 and and and, just read this https://developer.nvidia.com/vulkan-memory-management.\nSo let’s make one big memory allocation for each memory type requested by our engine and divide it for each resource according to their required size. It should be easy, right? Right? Yesn’t. You have to write a specialized data structure that fits your needs. With dumb_alloc, a memory region is divided into multiple contiguous blocks. Each block is characterized by an enabled boolean, a size and an offset. The enabled flag is straightforward, is this block actually used by a resource? offset defines the place in a specific VkDeviceMemory where the resource memory begins, while size defines the length of the block.\nYou want to allocate? In this data structure, you can either:\n Append a new block at the end. Insert a new block between two blocks.  You do (1) when you didn’t find enough free space by iterating through blocks with a enabled=false. You do (2) when you find a non-used block with a sufficient size. In this case, you divide the block into two parts: a used block and a non-used block. Before an alloc you join and check your blocks.\n join: contiguous disabled block are merged check: all blocks have to be contiguous alloc: find a place and return offset  With this dumb data structure which is nothing but a dynamic array you constantly resize and insert elements into, your memory is now structured adequately, and it’s trivial to find where you can place your resources. The dumb_alloc API allows you to do it in one line:\nVkMemoryRequirements memory_requirements; vkGetImageMemoryRequirements(device, image, \u0026memory_requirements); dumb_allocation_t image_allocation = dumb_allocate(device, \u0026memory_requirements, DUMB_MEMORY_USAGE_HOST_ONLY); vkBindImageMemory(device, image, image_allocation._memory, image_allocation._offset); Alignment of offset All offsets used to bind memory should be a multiple of VkMemoryRequirements::alignment. It’s the specifications. So our little approach has to be a little modified to be fully conform. On my 1050ti, image offsets have to be a multiple of 1024 and buffer offsets have to be a multiple of 256. The dumbest way to work around this vital part is to make a different vkDeviceMemory for each different memory alignment (SPOILER: we won’t do that). Thankfully, there is VkPhysicalDeviceLimits::bufferImageGranularity which is, if you let me paraphrase it, the lowest common multiple between buffer and image alignments. So let’s just allocate a block with a modified size. A size multiple of bufferImageGranularity so that each offset is necessarily conform to the memory requirement for both image and buffer.\nConclusion dumb_alloc is my personal vulkan memory allocator I’ve written for my vulkan projects. Instead of using an already made library, I chose to make it myself to understand a bit more the memory stuff around this hard API. In this blog post, we saw the underlying data structure of such an allocator and some motivations behind the implementation.\n","wordCount":"1021","inLanguage":"en","datePublished":"2021-08-31T12:50:50+02:00","dateModified":"2021-08-31T12:50:50+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://vinhig.github.io/posts/vulkan-memory-allocator/"},"publisher":{"@type":"Organization","name":"Portfolio Vincent Higginson","logo":{"@type":"ImageObject","url":"http://vinhig.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://vinhig.github.io/ accesskey=h title="Portfolio Vincent Higginson (Alt + H)">Portfolio Vincent Higginson</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
A dumb Vulkan Memory Allocator in plain C
</h1>
<div class=post-meta>August 31, 2021
</div>
</header>
<div class=post-content><p>By reading the github repository of the famous library Vulkan Memory Allocator written by the AMD team, you will see a kinda huge list of games and apps which are actually using it. From &ldquo;Detroit: Become Human&rdquo; to &ldquo;Skia&rdquo;, they are many who trust it. And they&rsquo;re right in a way. It does the job and it does it right. However, when you&rsquo;re learning a subject, you may want to investigate it deeply. You do not want to rely on whatever library is giving you some level of comfort (if it wasn&rsquo;t the case, I would have stayed with OpenGL).</p>
<p>So in this post (the first one of my newly created portfolio), I will explain <strong>how</strong> did I write my <em>dumb</em> memory allocator and <strong>why</strong> it&rsquo;s a dumb allocator. I do not ask you to blindly trust me, but I&rsquo;ve gained some level of confidence as I heavily use it throughout my projects.</p>
<h2 id=basics-concepts-of-memory-allocation>Basics concepts of memory allocation<a hidden class=anchor aria-hidden=true href=#basics-concepts-of-memory-allocation>#</a></h2>
<p>First of all, what&rsquo;s a memory allocator? Every resource you use in your program is actually a structured representation of bytes present in your physical memory. This piece of memory is characterized by a size and an address (<em>how many bytes would you eat?</em> and <em>where should I find those bytes?</em>). When you&rsquo;re writing basic CPU code, you&rsquo;re allocating with <em>malloc</em> (or a similar utility) which returns the actual address of the newly created piece of memory. Working with OpenGL, you&rsquo;re creating a resource with some specific size and everything is done magically by your driver. Don&rsquo;t you dare ask where did it put your data, you should not work directly with its address anyway.</p>
<p>Creating a vulkan resource (buffers and images, for example), doesn&rsquo;t mean allocating the required space. It&rsquo;s a separated action you <em>have to</em> execute to make the resource usable (creating an image view, binding the buffer as a vertex buffer, etc). That&rsquo;s where your allocator comes in. As you created your image with precise dimensions, your buffer with a precise size, it&rsquo;s easy to guess how your reserved piece of memory should be&mldr;</p>
<h2 id=guessing-the-required-size>Guessing the required size<a hidden class=anchor aria-hidden=true href=#guessing-the-required-size>#</a></h2>
<p>There is no guess! All you need is your physical device with which you can invoke:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>VkMemoryRequirements memory_requirements;
vkGetImageMemoryRequirements(device, image, memory_requirements);
<span style=color:#75715e>// or
</span><span style=color:#75715e></span>vkGetBufferMemoryRequirements(device, image, memory_requirements);
</code></pre></div><p>Easy easy! <code>memory_requirements</code> now contains everything you need to allocate: a size, a memory type and an alignement.</p>
<h2 id=allocating-for-your-resource>Allocating for your resource<a hidden class=anchor aria-hidden=true href=#allocating-for-your-resource>#</a></h2>
<p>A computer able to run vulkan code has different types of memory. I won&rsquo;t detail them exhaustively, but it&rsquo;s intuitive to think that depending on the usage of your resource, its place will be different. A mappable buffer and a color attachment texture aren&rsquo;t both requiring the same memory type, for example. In <code>dumb_alloc</code> code, I call them <em>memory region</em>.</p>
<p>I WANT TO ALLOCATE NOW, WHERE IS THE vkMalloc DUDE??? If you want to rush it, let&rsquo;s just acquire a VkDeviceMemory every time you need to bind memory to your vulkan object.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>VkMemoryAllocateInfo allocate_info <span style=color:#f92672>=</span> {
    .sType <span style=color:#f92672>=</span> VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
    .memoryTypeIndex <span style=color:#f92672>=</span> your_memory_type,
    .allocationSize <span style=color:#f92672>=</span> your_size,
};
vkAllocateMemory(device, <span style=color:#f92672>&amp;</span>allocate_info, NULL, <span style=color:#f92672>&amp;</span>device_memory)
</code></pre></div><p>Easy, fast, end of my post. You can leave now. The others who stayed, shame on this guy who wanted to speed run its allocation. It&rsquo;s a horrible practice. The number of memory allocations you can make is, in fact, very variable and limited. It can go from 4.096 to 4.294.970.000 and and and, just read this <a href=https://developer.nvidia.com/vulkan-memory-management>https://developer.nvidia.com/vulkan-memory-management</a>.</p>
<p>So let&rsquo;s make one big memory allocation for each memory type requested by our engine and divide it for each resource according to their required size. It should be easy, right? Right? Yesn&rsquo;t. You have to write a specialized data structure that fits your needs. With <code>dumb_alloc</code>, a memory region is divided into multiple contiguous blocks. Each block is characterized by an enabled boolean, a size and an offset. The <code>enabled</code> flag is straightforward, is this block actually used by a resource? <code>offset</code> defines the place in a specific VkDeviceMemory where the resource memory begins, while <code>size</code> defines the length of the block.</p>
<p>You want to allocate? In this data structure, you can either:</p>
<ol>
<li>Append a new block at the end.</li>
<li>Insert a new block between two blocks.</li>
</ol>
<p>You do (1) when you didn&rsquo;t find enough free space by iterating through blocks with a <code>enabled=false</code>. You do (2) when you find a non-used block with a sufficient size. In this case, you divide the block into two parts: a used block and a non-used block. Before an <code>alloc</code> you <code>join</code> and <code>check</code> your blocks.</p>
<ul>
<li>join: contiguous disabled block are merged</li>
<li>check: all blocks have to be contiguous</li>
<li>alloc: find a place and return offset</li>
</ul>
<p>With this <em>dumb</em> data structure which is nothing but a dynamic array you constantly resize and insert elements into, your memory is now structured adequately, and it&rsquo;s trivial to find where you can place your resources. The <code>dumb_alloc</code> API allows you to do it in one line:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>VkMemoryRequirements memory_requirements;
vkGetImageMemoryRequirements(device, image, <span style=color:#f92672>&amp;</span>memory_requirements);

dumb_allocation_t image_allocation <span style=color:#f92672>=</span> dumb_allocate(device, <span style=color:#f92672>&amp;</span>memory_requirements, DUMB_MEMORY_USAGE_HOST_ONLY);
vkBindImageMemory(device, image, image_allocation._memory, image_allocation._offset);
</code></pre></div><h2 id=alignment-of-offset>Alignment of offset<a hidden class=anchor aria-hidden=true href=#alignment-of-offset>#</a></h2>
<p>All offsets used to bind memory should be a multiple of <code>VkMemoryRequirements::alignment</code>. It&rsquo;s the specifications. So our little approach has to be a little modified to be fully conform. On my 1050ti, image offsets have to be a multiple of 1024 and buffer offsets have to be a multiple of 256. The <em>dumb</em>est way to work around this vital part is to make a different <code>vkDeviceMemory</code> for each different memory alignment (SPOILER: we won&rsquo;t do that). Thankfully, there is <code>VkPhysicalDeviceLimits::bufferImageGranularity</code> which is, if you let me paraphrase it, the lowest common multiple between buffer and image alignments. So let&rsquo;s just allocate a block with a modified size. A size multiple of bufferImageGranularity so that each offset is necessarily conform to the memory requirement for both image and buffer.</p>
<h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2>
<p><code>dumb_alloc</code> is my personal vulkan memory allocator I&rsquo;ve written for my vulkan projects. Instead of using an already made library, I chose to make it myself to understand a bit more the memory stuff around this hard API. In this blog post, we saw the underlying data structure of such an allocator and some motivations behind the implementation.</p>
</div>
<footer class=post-footer>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=http://vinhig.github.io/>Portfolio Vincent Higginson</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>